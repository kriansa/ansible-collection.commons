---
- name: Define secure SSH server standards
  become: true
  notify: Restart ssh
  ansible.builtin.copy:
    dest: /etc/ssh/sshd_config.d/99-secure-defaults.conf
    mode: "0644"
    content: |
      PasswordAuthentication no
      PermitRootLogin no

- name: Restrict su to wheel group only
  become: true
  ansible.builtin.blockinfile:
    path: /etc/pam.d/su
    insertafter: "auth\\s+sufficient\\s+pam_rootok.so"
    block: |
      # Allow wheel members to `su` without password
      auth sufficient pam_wheel.so trust use_uid

- name: Restrict passwordless sudo to wheel group only
  become: true
  ansible.builtin.copy:
    content: |
      # Enable wheel group to execute all commands without password
      %wheel ALL=(ALL) NOPASSWD:ALL
    dest: /etc/sudoers.d/10-wheel
    mode: "0600"

- name: Reset ssh connection
  ansible.builtin.meta: reset_connection

- name: Lock root user password
  become: true
  ansible.builtin.user:
    name: root
    password_lock: true

# Hardens kernel tunables
# See: https://github.com/Kicksecure/security-misc
# See: https://madaidans-insecurities.github.io/guides/linux-hardening.html
# See: https://tails.net/contribute/design/kernel_hardening/
# See: https://kernsec.org/wiki/index.php/Kernel_Self_Protection_Project/Recommended_Settings
- name: Hardens sysctl variables
  become: true
  ansible.posix.sysctl:
    name: "{{ item.name }}"
    value: "{{ item.value }}"
    sysctl_set: true
    sysctl_file: /etc/sysctl.d/80-hardened-settings.conf
  loop:
      ## Hides kernel addresses in various files in /proc.
      ## Kernel addresses can be very useful in certain exploits.
      ##
      ## https://kernsec.org/wiki/index.php/Bug_Classes/Kernel_pointer_leak
    - { name: kernel.kptr_restrict, value: "1" }

      # Panics whenever an oops or bug is encountered.
    - { name: kernel.panic_on_oops, value: "1" }

      # Hardens the BPF JIT compiler and restricts it to root.
    - { name: net.core.bpf_jit_harden, value: "2" }
    - { name: kernel.unprivileged_bpf_disabled, value: "1" }

      # Randomize the addresses for mmap base, heap, stack, and VDSO pages
    - { name: kernel.randomize_va_space, value: "2" }

      ## Restrict loading TTY line disciplines to CAP_SYS_MODULE to prevent
      ## unprivileged attackers from loading vulnerable line disciplines
      ## with the TIOCSETD ioctl which has been used in exploits before
      ## such as https://a13xp0p0v.github.io/2017/03/24/CVE-2017-2636.html
      ##
      ## https://lkml.org/lkml/2019/4/15/890
    - { name: dev.tty.ldisc_autoload, value: "0" }

      ## Restrict the userfaultfd() syscall to root as it can make heap sprays
      ## easier.
      ##
      ## https://duasynt.com/blog/linux-kernel-heap-spray
    - { name: vm.unprivileged_userfaultfd, value: "0" }

      ## Disallow kernel profiling by users without CAP_SYS_ADMIN
      ## https://www.kernel.org/doc/Documentation/sysctl/kernel.txt
    - { name: kernel.perf_event_paranoid, value: "3" }

      # kexec is a system call that is used to boot another kernel during runtime. This functionality
      # can be abused to load a malicious kernel and gain arbitrary code execution in kernel mode, so
      # this sysctl disables it.
    - { name: kernel.kexec_load_disabled, value: "1" }

      ## Disable SysRq key
    - { name: kernel.sysrq, value: "0" }

      ## Restricts the kernel log to root only.
    - { name: kernel.dmesg_restrict, value: "1" }

      ## Don't allow writes to files that we don't own
      ## in world writable sticky directories, unless
      ## they are owned by the owner of the directory.
    - { name: fs.protected_fifos, value: "2" }
    - { name: fs.protected_regular, value: "2" }

      ## Only allow symlinks to be followed when outside of
      ## a world-writable sticky directory, or when the owner
      ## of the symlink and follower match, or when the directory
      ## owner matches the symlink's owner.
      ##
      ## Prevent hardlinks from being created by users that do not
      ## have read/write access to the source file.
      ##
      ## These prevent many TOCTOU races.
    - { name: fs.protected_symlinks, value: "1" }
    - { name: fs.protected_hardlinks, value: "1" }

- name: Check if cmdline is hardened
  ansible.builtin.command: grep -q "slab_nomerge" /proc/cmdline
  changed_when: os_base_cmdline_hardened.rc == 0
  failed_when: false
  register: os_base_cmdline_hardened

- name: Hardens kernel command line arguments
  become: true
  when: not os_base_cmdline_hardened.changed
  notify: Reboot
  ansible.builtin.command: grubby --update-kernel=ALL --args="{{ item }}"
  changed_when: true
  loop:
    # Disables the merging of slabs of similar sizes.
    # Sometimes a slab can be used in a vulnerable way which an attacker can exploit.
    - slab_nomerge

    # This option randomises page allocator freelists, improving security by making page allocations
    # less predictable. This also improves performance.
    - page_alloc.shuffle=1

    # Zero memory at allocation and free time.
    - init_on_free=1 init_on_alloc=1

    # Mostly useful for systems with ECC memory, setting mce to 0 will cause the kernel to panic on
    # any uncorrectable errors detected by the machine check exception system. Corrected errors will
    # just be logged. The default is mce=1, which will SIGBUS on many uncorrected errors.
    # Unfortunately this means malicious processes which try to exploit hardware bugginess (such as
    # rowhammer) will be able to try over and over, suffering only a SIGBUS at failure. Setting
    # mce=0 should have no impact. Any hardware which regularly triggers a memory-based MCE is
    # unlikely to even boot, and the default is 1 only for long-lived servers.
    - mce=0

    # Vsyscalls are obsolete, are at fixed addresses and are a target for ROP.
    - vsyscall=none

    # Enables randomisation of the kernel stack offset on syscall entries (introduced in kernel 5.13).
    # https://lkml.org/lkml/2019/3/18/246
    - randomize_kstack_offset=on

    # Restrict access to debugfs since it can contain a lot of sensitive information.
    # https://lkml.org/lkml/2020/7/16/122
    # https://github.com/torvalds/linux/blob/fb1201aececc59990b75ef59fca93ae4aa1e1444/Documentation/admin-guide/kernel-parameters.txt#L835-L848
    - debugfs=off

    # Always enable Kernel Page Table Isolation, even if the CPU claims it is safe from Meltdown.
    - pti=on

- name: Hardens kernel command line arguments for bare metal
  become: true
  notify: Reboot
  ansible.builtin.command: grubby --update-kernel=ALL --args="{{ item }}"
  changed_when: true
  when: ansible_facts.virtualization_role == "host" and cmdline_hardened.rc != 0
  loop:
    # Enables IOMMU to prevent DMA attacks.
    - intel_iommu=on amd_iommu=force_isolation

    # Disable the busmaster bit on all PCI bridges during very
    # early boot to avoid holes in IOMMU.
    #
    # This option may cause failures with some poorly behaved hardware and
    # should not be enabled without testing. The kernel commandline options
    # "efi=disable_early_pci_dma" or "efi=no_disable_early_pci_dma" may be
    # used to override the default. Note that PCI devices downstream from PCI
    # bridges are disconnected from their drivers first, using the UEFI
    # driver model API, so that DMA can be disabled safely at the bridge
    # level.
    #
    # https://mjg59.dreamwidth.org/54433.html
    # https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=4444f8541dad16fefd9b8807ad1451e806ef1d94
    - efi=disable_early_pci_dma

    # Enables strict enforcement of IOMMU TLB invalidation so devices will never be able to access stale data contents
    # https://github.com/torvalds/linux/blob/master/drivers/iommu/Kconfig#L97
    # Page 11 of https://lenovopress.lenovo.com/lp1467.pdf
    - iommu=force iommu.passthrough=0 iommu.strict=1
